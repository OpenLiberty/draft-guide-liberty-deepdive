// =================================================================================================
// Defining a JPA entity class
// =================================================================================================

== Defining a JPA entity class

Navigate to the `start` directory to begin.

When you run Open Liberty in dev mode, the server listens for file changes and automatically recompiles and deploys your updates whenever you save a new change.

Run the following command to start the system service in dev mode:

[role='command']
```
mvn liberty:dev
```

After you see the following message, your application server in dev mode is ready:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

Dev mode holds your command line to listen for file changes. Open another command-line session to continue, 
or open the project in your editor.

To store Java objects in a database, you must define a JPA entity class. A JPA entity is a Java 
object whose non-transient and non-static fields will be persisted to the database. Any Plain Old 
Java Object (POJO) class can be designated as a JPA entity. However, the class must be annotated
with the `@Entity` annotation, must not be declared final and must have a public or protected non-argument
constructor. JPA maps an entity type to a database table and persisted instances will be represented 
as rows in the table.

The [hotspot=SystemData]`SystemData` class is a data model that represents systems in the system microservice and is annotated with JPA
annotations.

[role="code_command hotspot", subs="quotes"]
----
#Create the `SystemData` class.#
`/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----
SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

The following table breaks down the new annotations:

[cols="35, 200", options="header"]
|===
| *Annotation*    | *Description*
| [hotspot=Entity]`@Entity` | Declares the class as an entity
| [hotspot=Table]`@Table`  | Specifies details of the table such as name 
| [hotspot=NamedQuery]`@NamedQuery` | Specifies a predefined database query that is run by an `EntityManager` instance.
| [hotspot=Id]`@Id`       |  Declares the primary key of the entity
| [hotspot=GeneratedValue]`@GeneratedValue`    | Specifies the strategy used for generating the value of the primary key. The `strategy = GenerationType.IDENTITY` code indicates that the database will automatically increment the `inventoryid` automatically upon inserting into the database
| [hotspot=Column]`@Column`    | Specifies that the field is mapped to a column in the database table. The `name` attribute is optional and indicates the name of the column in the table
|===

// =================================================================================================
// Configuring JPA
// =================================================================================================

== Configuring JPA

The [hotspot file=0]`persistence.xml` file is a configuration file that defines a persistence unit. The
persistence unit specifies configuration information for the entity manager.

[role="code_command hotspot", subs="quotes"]
----
#Create the configuration file.#
`src/main/resources/META-INF/persistence.xml`
----
persistence.xml
[source, Xml, linenums, role='code_column']
----
include::src/main/resources/META-INF/persistence.xml[]
----

The persistence unit is defined by the [hotspot=persistence-unit file=0]`persistence-unit` XML element. The [hotspot=transaction-type file=0]`name` attribute is 
required and is used to identify the persistent unit when using the `@PersistenceContext`
annotation to inject the entity manager later in this guide. The [hotspot=transaction-type file=0]`transaction-type="JTA"` 
attribute specifies to use Java Transaction API (JTA) transaction management.
Since we are using a container-managed entity manager, JTA transactions must be used. 

A JTA transaction type requires a JTA data source to be provided. The [hotspot=jta-data file=0]`jta-data-source` 
element specifies the Java Naming and Directory Interface (JNDI) name of 
the data source that is used. The [hotspot=data-source file=1]`data source` has already been configured for you
in the [hotspot file=1]`src/main/liberty/config/server.xml` file. This data source configuration is where 
the Java Database Connectivity (JDBC) connection is defined along with some database
vendor-specific properties.

server.xml
[source, Xml, linenums, role='code_column']
----
include::src/main/liberty/config/server.xml[]
----

// =================================================================================================
// Performing CRUD operations using JPA
// =================================================================================================

== Performing CRUD operations using JPA

The CRUD operations are defined in the Inventory. To perform these operations by using JPA, we need an [hotspot=Inventory file=0]`Inventory` class. 

[role="code_command hotspot", subs="quotes"]
----
#Create the `Inventory` class.#
`src/main/java/io/openliberty/deepdive/rest/Inventory.java`
----
Inventory.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::src/main/java/io/openliberty/deepdive/rest/Inventory.java[]
----

To use the entity manager at runtime, inject it into our CDI bean through the
[hotspot=PersistenceContext file=0]`@PersistenceContext` annotation. The entity manager interacts with the persistence context. 
Every `EntityManager` instance is associated with a persistence context. The persistence context 
manages a set of entities and is aware of the different states that an entity can have.
The persistence context synchronizes with the database when a transaction commits.

The [hotspot=Inventory file=0]`Inventory` class has a method for each CRUD operation, so let's break them down:

* The [hotspot=addToInventory file=0]`add()` method persists an instance of the [hotspot=SystemData file=1]`SystemData` entity class to the data store by calling the [hotspot=Persist file=0]`persist()` method on an `EntityManager` instance. The entity instance becomes managed and changes to it will be tracked by the entity manager.

* The [hotspot=getSystem file=0]`getSystem()` method returns an instance of the [hotspot=SystemData file=1]`SystemData` entity class with the specified primary key by calling the [hotspot=Find file=0]`find()` method on an `EntityManager` instance. If the system instance is found, it is returned in a managed state, but, if the system instance is not found, `null` is returned.

* The [hotspot=getSystems file=0]`getSystems()` method demonstrates an alternative way to retrieve system objects from the database. This method returns a list of instances of the `SystemData` entity class by using the `SystemData.findAll` query specified in the [hotspot=NamedQuery file=1]`@NamedQuery` annotation on the [hotspot=SystemData file=1]`SystemData` class. Similarly, the [hotspot=getSystem file=0]`getSystem()` method uses the `SystemData.getSystem` named query to find an system with the given name, location and time. 

SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

* The [hotspot=update file=0]`update()` method creates a managed instance of a detached entity instance. The entity manager automatically tracks all managed entity objects in its persistence context for changes and synchronizes them with the database. However, if an entity becomes detached, you must merge that entity into the persistence context by calling the [hotspot=Merge file=0]`merge()` method so that changes to loaded fields of the detached entity are tracked.

* The [hotspot=removeSystem file=0]`removeSystem()` method removes an instance of the [hotspot=SystemData file=1]`SystemData` entity class from the database by calling the [hotspot=Remove file=0]`remove()` method on an `EntityManager` instance. The state of the entity is changed to removed and is removed from the database upon transaction commit. 

The Inventory is injected into the [hotspot=DAO file=2]`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
class and used to access and persist data. The [hotspot=Transactional file=2]`@Transactional` annotation is used in the
[hotspot=SystemResource file=2]`SystemResource` class to declaratively control the transaction boundaries on the [hotspot=RequestedScoped file=2]`@RequestScoped` CDI bean.
This ensures that the methods run within the boundaries of an active global transaction, which is why it is not
necessary to explicitly begin, commit or rollback transactions. At the end of the transactional
method invocation, the transaction commits and the persistence context flushes any changes
to SystemData entity instances it is managing to the database.

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

// =================================================================================================
// Adding and Configuring the database
// =================================================================================================
You will use Docker to run an instance of PostgreSQL for a fast installation and setup.

A multi-stage Dockerfile is provided for you.
This Dockerfile uses the `postgres` image as the base image of the final stage and gathers the required configuration files.
The resulting `postgres` image runs in a Docker container, and you must set up a new database for the microservice.
Lastly, the schema needed to store the Systems is also provided under `schema.sql`. 


**Running PostgreSQL in a Docker container**

Run the following commands to use the Dockerfile to build the image, run the image in a Docker container,
and map port `5432` from the container to your host machine:

[role='command']
```
docker build -t postgres-sample -f assets/Dockerfile .
docker run --name postgres-container -p 5432:5432 -d postgres-sample
```

// =================================================================================================
// Building and running the application
// =================================================================================================

[role=command]
include::{common-includes}/devmode-build.adoc[]

When the server is running, go to the {eventapp-url} URL to view the Event Manager application. 

Click `Create System` in the left navigation bar to create events that are persisted to 
the database. After you create an event, it is available to view, update, and delete in
the `Current Events` section.

When you are done checking out the services, exit dev mode by pressing CTRL+C in the command-line sessions where you
ran the `frontendUI` and `backendServices` services,  or by typing `q` and then pressing the `enter/return` key.
Alternatively, you can run the `liberty:stop` goal from the `start` directory in another command-line session for the `frontendUI`
and `backendServices` services:

[role="command"]
----
mvn liberty:stop
----