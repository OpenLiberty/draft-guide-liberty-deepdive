// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: liberty-deepdive
:page-layout: guide-multipane
:page-duration: 100 minutes
:page-releasedate: 2022-03-31
:page-essential: false
:page-description: Learn how to use Liberty to develop microservice.
:page-tags: []
:page-related-guides: []
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Implementing a microservice using Jakarta EE and MicroProfile API
:page-seo-description: A tutorial with examples on how to implement a microservice using Jakarta EE and Eclipse MicroProfile API.
:guide-author: Open Liberty
= Liberty deepdive class

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form,
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Liberty is a cloud-optimized Java runtime that is fast to start up with a low memory footprint and a dev mode for quick iteration. Adding and removing features to adopt the latest open cloud-native Java API like MicroProfile and Jakarta EE are easy with Liberty. Liberty's zero migration lets you focus on what's important and not the APIs changing under you.

== What you'll learn

You will learn how to build...

== Additional prerequisites

Before you begin, Docker needs to be installed before starting the module of Presisting Data.
For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^].
You'll build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

///////////////////////////
// Getting started
///////////////////////////

[role='command']
include::{common-includes}/gitclone.adoc[]

== Getting started

Create a maven project by OL starter.

Develop an RESTful microservice.

== Documenting APIs

Document the RESTful APIs by using MicroProfile OpenAPI

==  Configuring the microservice

configure the context root and port

provide external configuration to the microservice using MicroProfile Config

== Persisting data

use JPA to access and persist data to a database for the microservice

== Securing RESTful APIs

secure the RESTful APIs

== Consuming the secured RESTful APIs by JWT

use JWT/jwtSso to consume/call the secured RESTful APIs 

== Adding health checks

use MicroProfile Health to report the health status of the microservice

== Providing metrics

use MicroProfile Metrics to provide metrics from the microservice

== Testing the microservice

use test containger to test the microservice

== Building the container 

Navigate to the `start/module-10` directory.

The first step to containerizing your application inside of a Docker container is creating a Dockerfile. A Dockerfile is a collection of instructions for building a Docker image that can then be run as a container. 

Make sure to start your Docker daemon before you proceed.

[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Dockerfile` in the `start/module-10` directory.#
`Dockerfile`
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your image is built. In this case, you’re using the `icr.io/appcafe/open-liberty:full-java11-openj9-ubi` image as your parent image, which comes with the latest Open Liberty runtime.

To help you manage your images, you can label your container images with the [hotspot=label file=0]`LABEL` command. 

The [hotspot=copy file=0]`COPY` instructions are structured as `COPY` `[--chown=<user>:<group>]` `<source>` `<destination>`. They copy local files into the specified destination within your Docker image. In this case, the first [hotspot=copy-config file=0]`COPY` instruction copies the server configuration file that is located at `src/main/liberty/config/server.xml` to the `/config/` destination directory. Similarly, the second [hotspot=copy-war file=0]`COPY` instruction copies the `.war` file to the `/config/apps` destination directory.

Dockerfile
[source, text, linenums, role="code_column"]
----
include::finish/module-10/Dockerfile[]
----
=== Launching Open Liberty in dev mode

Having created the Dockerfile, you can now use the `devc` goal to run your application. 

The Open Liberty Maven plug-in includes a `devc` goal that builds a Docker image, mounts the required directories, binds the required ports, and then runs the application inside of a container. This development mode, known as dev mode, also listens for any changes in the application source code or configuration and rebuilds the image and restarts the container as necessary.

Build and run the container by running the `devc` goal from the `start/module-10` directory:

[role='command']
```
mvn liberty:devc
```

After you see the following message, your application server in dev mode is ready:
[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

Open another command-line session and run the following command to make sure that your
container is running and didn’t crash:

[role='command']
```
docker ps 
```

You should see something similar to the following output:

[role="no_copy"]
----
CONTAINER ID        IMAGE                                 COMMAND                  CREATED             STATUS              PORTS                                                                    NAMES
ee2daf0b33e1        liberty-deepdive-inventory-dev-mode   "/opt/ol/helpers/run…"   2 minutes ago       Up 2 minutes        0.0.0.0:7777->7777/tcp, 0.0.0.0:9080->9080/tcp, 0.0.0.0:9443->9443/tcp   liberty-dev
----

When you are finished, press CTRL+C in the session that the dev mode was started from to stop and remove the container.

=== Building the container image

Run the `mvn package` command from the `start/module-10` directory so that the `.war` file resides in the `target` directory.

[role='command']
```
mvn package
```

include::{common-includes}/ol-icr-full-docker-pull.adoc[]

Build your Docker image with the following commands:

[role='command']
```
docker build -t liberty-deepdive-inventory:1.0-SNAPSHOT .
```

When the build finishes, run the following command to list all local Docker images:
[role='command']
```
docker images
```

Verify that the `liberty-deepdive-inventory:1.0-SNAPSHOT` image is listed among the Docker images, for example:
[source, role="no_copy"]
----
REPOSITORY                      TAG
liberty-deepdive-inventory      1.0-SNAPSHOT
openliberty/open-liberty        full-java11-openj9-ubi
----

== Deploying the microservice to Kubernetes

Now that the containerized application is built, deploy it to a local Kubernetes cluster. 

=== Installing the Open Liberty Operator 

To do so, first, install the Open Liberty Opertor deploy the microservice to Kubernetes.

First, install Custom Resource Definitions (CRDs) for the Open Liberty Operator by running the following command:
[role='command']
```
kubectl apply -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
Custom Resources extend the Kubernetes API and enhance its functionality.

Set environment variables for namespaces for the Operator by running the following commands:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
set OPERATOR_NAMESPACE=default
set WATCH_NAMESPACE=\"\"
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
OPERATOR_NAMESPACE=default
WATCH_NAMESPACE='""'
```
--

Next, run the following commands to install cluster-level role-based access:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
curl https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml -o openliberty-app-rbac-watch-all.yaml

powershell -Command "(gc .\openliberty-app-rbac-watch-all.yaml) -replace 'OPEN_LIBERTY_OPERATOR_NAMESPACE', '%OPERATOR_NAMESPACE%' | Out-File -encoding ASCII .\openliberty-app-rbac-watch-all.yaml"

kubectl apply -f .\openliberty-app-rbac-watch-all.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml \
  | sed -e "s/OPEN_LIBERTY_OPERATOR_NAMESPACE/${OPERATOR_NAMESPACE}/" \
  | kubectl apply -f -
```
--

Finally, run the following commands to install the Operator:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
curl https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml -o openliberty-app-operator.yaml

powershell -Command "(gc .\openliberty-app-operator.yaml) -replace 'OPEN_LIBERTY_WATCH_NAMESPACE', '%WATCH_NAMESPACE%' | Out-File -encoding ASCII .\openliberty-app-operator.yaml"

kubectl apply -n %OPERATOR_NAMESPACE% -f .\openliberty-app-operator.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml \
  | sed -e "s/OPEN_LIBERTY_WATCH_NAMESPACE/${WATCH_NAMESPACE}/" \
  | kubectl apply -n ${OPERATOR_NAMESPACE} -f -
```
--

To check that the Open Liberty Operator has been installed successfully, run the following command to view all the supported API resources that are available through the Open Liberty Operator:
[role='command']
```
kubectl api-resources --api-group=apps.openliberty.io
```

Look for the following output, which shows the https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[custom resource definitions^] (CRDs) that can be used by the Open Liberty Operator:

[role='no_copy']
```
NAME                      SHORTNAMES         APIGROUP              NAMESPACED   KIND
openlibertyapplications   olapp,olapps       apps.openliberty.io   true         OpenLibertyApplication
openlibertydumps          oldump,oldumps     apps.openliberty.io   true         OpenLibertyDump
openlibertytraces         oltrace,oltraces   apps.openliberty.io   true         OpenLibertyTrace
```

Each CRD defines a kind of object that can be used, which is specified in the previous example by the `KIND` value. The `SHORTNAME` value specifies alternative names that you can substitute in the configuration to refer to an object kind. For example, you can refer to the `OpenLibertyApplication` object kind by one of its specified shortnames, such as `olapps`. 

The `openlibertyapplications` CRD defines a set of configurations for deploying an Open Liberty-based application, including the application image, number of instances, and storage settings. The Open Liberty Operator watches for changes to instances of the `OpenLibertyApplication` object kind and creates Kubernetes resources that are based on the configuration that is defined in the CRD.

=== Running the application

inventory.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-11/inventory.yaml[]
----

postgres.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-11/postgres.yaml[]
----

A Kubernetes resource definition is provided in the [hotspot file=0]`inventory.yaml` file at the `start/module-11` directory.

In the [hotspot file=0]`inventory.yaml` file, the custom resource (CR) is specified to be [hotspot=kind file=0]`OpenLibertyApplication`. The CR triggers the Open Liberty Operator to create, update or delete Kubernetes resources needed by the application to run on your cluster. Additionally, the [hotspot=applicationImage file=0]`applicationImage` field must be specified, and is set to the image created in the previous module. 

Run the following command to deploy the application:
[role='command']
```
kubectl apply -f inventory.yaml
```

Similarly, in the [hotspot file=1]`postgres.yaml` file, the deployment for the postgres database is defined. To ensure that data persists even when a container does not, a [hotspot=persistentVolume file=1]`PersistentVolume` resource is defined. It allows the data from the database to be stored in a permanent location. The [hotspot=persistentVolumeClaim file=1]`PersistentVolumeClaim` acts to request the `PersistentVolume` resource. Next, the [hotspot=deployment file=1]`Deployment` acts to deploy the necessary Kubernetes resources to serve the database. Finally, the the [hotspot=service file=1]`Service` exposes the postgres service on an cluster-internal IP, so the inventory service can make requests to it.

Before deploying the postgres service, create a Secret to configure the new credentials that create a new user `admin`.
[role='command']
```
kubectl create secret generic post-app-credentials --from-literal username=admin --from-literal password=adminpwd
```

The credentials are passed to the postgres database as [hotspot=env file=1]`environment variables`. 

Run the following command to deploy the database:
[role='command']
```
kubectl apply -f postgres.yaml
```

When the application is deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You see an output similar to the following if all the pods are working correctly:

[role="no_copy"]
----
NAME                                    READY   STATUS    RESTARTS   AGE
inventory-deployment-75f9dc56d9-g9lzl   1/1     Running   0          35s
postgres-58bd9b55c7-6vzz8               1/1     Running   0          13s
----

You can check out the service at the http://localhost:31000/openapi/ui/[http://localhost:31000/openapi/ui/^] URL.

=== Customizing deployments

inventory.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-11/update/inventory.yaml[]
----

server.xml
[source, xml, linenums, role='code_column']
----
include::finish/module-11/update/server.xml[]
----

You can modify the [hotspot file=0]`inventory.yaml` file to customize the deployments. Customizations for a service include changing the port number, changing the context root, and passing confidential information using Secrets. 

[role="code_command hotspot file=1"", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

In the [hotspot file=1]`server.xml`, the [hotspot=contextRoot file=1]`context.root` variable is defined. The context root for the inventory service can be changed using this variable. The value for the [hotspot=contextRoot file=1]`context.root` variable can be defined in a ConfigMap and accessed as a environment variable.

Create a ConfigMap to configure the app name with the following kubectl command.
[role='command']
```
kubectl create configmap inv-app-root --from-literal contextRoot=/dev
```
This command deploys a ConfigMap named `inv-app-root` to your cluster. It has a key called `contextRoot` with a value of `/dev`. The `--from-literal` flag allows you to specify individual key-value pairs to store in this ConfigMap. 

[role="code_command hotspot file=0"", subs="quotes"]
----
#Replace the `inventory.yaml` file.#
`inventory.yaml`
----

During deployment, `post-app-credentials` secret can be mounted to the [hotspot=mountPath file=0]`/config/variables/postgres` in the pod to create Liberty config variables. Liberty will create variables from the files in the [hotspot=mountPath file=1]`/config/variables/postgres` directory. Instead of including confidential information in the `server.xml`, users can access it using normal Liberty variable syntax, [hotspot=postgresUser file=1]`${postgres/username}` and [hotspot=postgresUser file=1]`${postgres/password}`.

Finally, the [hotspot=port file=0]`port` number is updated to `30000`, so the service will now be available at port `30000`.

Run the following command to deploy your changes to rebuild the Docker image and deploy the Kubernetes cluster.
[role='command']
```
mvn package
docker build -t liberty-deepdive-inventory:1.0-SNAPSHOT .
kubectl replace --force -f inventory.yaml
```

You can now check out the service at the http://localhost:30000/openapi/ui/[http://localhost:30000/openapi/ui/^] URL.

=== Tearing down the environment 

Once you are done, you can delete all Kubernetes resources by running the `kubectl delete` command:

[role='command']
```
kubectl delete -f inventory.yaml
kubectl delete -f postgres.yaml
kubectl delete configmap inv-app-root
kubectl delete secret post-app-credentials
```

To uninstall the Open Liberty Operator, run the following commands:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
set OPERATOR_NAMESPACE=default
set WATCH_NAMESPACE=\"\"

kubectl delete -n %OPERATOR_NAMESPACE% -f .\openliberty-app-operator.yaml

kubectl delete -f .\openliberty-app-rbac-watch-all.yaml

kubectl delete -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
OPERATOR_NAMESPACE=default
WATCH_NAMESPACE='""'

curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml \
  | sed -e "s/OPEN_LIBERTY_WATCH_NAMESPACE/${WATCH_NAMESPACE}/" \
  | kubectl delete -n ${OPERATOR_NAMESPACE} -f -

curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml \
  | sed -e "s/OPEN_LIBERTY_OPERATOR_NAMESPACE/${OPERATOR_NAMESPACE}/" \
  | kubectl delete -f -

kubectl delete -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
--

== Support Licensing

use WebSphere Liberty


== Great work! You're done!

You just learnt to build a microservice in Open Liberty!

include::{common-includes}/attribution.adoc[]
