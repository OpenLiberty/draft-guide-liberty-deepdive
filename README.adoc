// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: liberty-deepdive
:page-layout: guide-multipane
:page-duration: 100 minutes
:page-releasedate: 2022-03-31
:page-essential: false
:page-description: Learn how to use Liberty to develop microservice.
:page-tags: []
:page-related-guides: []
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Implementing a microservice using Jakarta EE and MicroProfile API
:page-seo-description: A tutorial with examples on how to implement a microservice using Jakarta EE and Eclipse MicroProfile API.
:guide-author: Open Liberty
= Liberty deepdive class

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form,
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Liberty is a cloud-optimized Java runtime that is fast to start up with a low memory footprint and a dev mode for quick iteration. Adding and removing features to adopt the latest open cloud-native Java API like MicroProfile and Jakarta EE are easy with Liberty. Liberty's zero migration lets you focus on what's important and not the APIs changing under you.

== What you'll learn

You will learn how to build...

== Additional prerequisites

Before you begin, Docker needs to be installed before starting the module of Presisting Data.
For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^].
You'll build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

///////////////////////////
// Getting started
///////////////////////////

[role='command']
include::{common-includes}/gitclone.adoc[]

== Getting started

Create a maven project by OL starter.

Develop an RESTful microservice.

== Documenting APIs

Document the RESTful APIs by using MicroProfile OpenAPI

==  Configuring the microservice

configure the context root and port

provide external configuration to the microservice using MicroProfile Config

== Persisting data

use JPA to access and persist data to a database for the microservice

== Securing RESTful APIs

secure the RESTful APIs

== Consuming the secured RESTful APIs by JWT

use JWT/jwtSso to consume/call the secured RESTful APIs 

== Adding health checks

use MicroProfile Health to report the health status of the microservice

== Providing metrics

use MicroProfile Metrics to provide metrics from the microservice

== Testing the microservice

use test containger to test the microservice

== Building the container 

Navigate to the `start/module-10` directory.

The first step to containerizing your application inside of a Docker container is creating a Dockerfile. A Dockerfile is a collection of instructions for building a Docker image that can then be run as a container. 

Make sure to start your Docker daemon before you proceed.

[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Dockerfile` in the `start/module-10` directory.#
`Dockerfile`
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your image is built. In this case, you’re using the `icr.io/appcafe/open-liberty:full-java11-openj9-ubi` image as your parent image, which comes with the latest Open Liberty runtime.

To help you manage your images, you can label your container images with the [hotspot=label file=0]`LABEL` command. 

The [hotspot=copy file=0]`COPY` instructions are structured as `COPY` `[--chown=<user>:<group>]` `<source>` `<destination>`. They copy local files into the specified destination within your Docker image. In this case, the first [hotspot=copy-config file=0]`COPY` instruction copies the server configuration file that is located at `src/main/liberty/config/server.xml` to the `/config/` destination directory. Similarly, the second [hotspot=copy-war file=0]`COPY` instruction copies the `.war` file to the `/config/apps` destination directory.

Dockerfile
[source, text, linenums, role="code_column"]
----
include::finish/module-10/Dockerfile[]
----
=== Launching Open Liberty in dev mode

Having created the Dockerfile, you can now use the `devc` goal to run your application. 

The Open Liberty Maven plug-in includes a `devc` goal that builds a Docker image, mounts the required directories, binds the required ports, and then runs the application inside of a container. This development mode, known as dev mode, also listens for any changes in the application source code or configuration and rebuilds the image and restarts the container as necessary.

Build and run the container by running the `devc` goal from the `start/module-10` directory:

[role='command']
```
mvn liberty:devc
```

After you see the following message, your application server in dev mode is ready:
[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

Open another command-line session and run the following command to make sure that your
container is running and didn’t crash:

[role='command']
```
docker ps 
```

You should see something similar to the following output:

[role="no_copy"]
----
CONTAINER ID        IMAGE                                 COMMAND                  CREATED             STATUS              PORTS                                                                    NAMES
ee2daf0b33e1        liberty-deepdive-inventory-dev-mode   "/opt/ol/helpers/run…"   2 minutes ago       Up 2 minutes        0.0.0.0:7777->7777/tcp, 0.0.0.0:9080->9080/tcp, 0.0.0.0:9443->9443/tcp   liberty-dev
----

Check out the service at the http://localhost:9080/openapi/ui[http://localhost:9080/openapi/ui^] URL.

When you are finished, press CTRL+C in the session that the dev mode was started from to stop and remove the container.

=== Building the container image

Run the `mvn package` command from the `start/module-10` directory so that the `.war` file resides in the `target` directory.

[role='command']
```
mvn package
```

include::{common-includes}/ol-icr-full-docker-pull.adoc[]

Build your Docker image with the following commands:

[role='command']
```
docker build -t liberty-deepdive-inventory:1.0-SNAPSHOT .
```

When the build finishes, run the following command to list all local Docker images:
[role='command']
```
docker images
```

Verify that the `liberty-deepdive-inventory:1.0-SNAPSHOT` image is listed among the Docker images, for example:
[source, role="no_copy"]
----
REPOSITORY                      TAG
liberty-deepdive-inventory      1.0-SNAPSHOT
openliberty/open-liberty        full-java11-openj9-ubi
----

== Deploying the microservice to Kubernetes

Now that the containerized application is built, deploy it to a local Kubernetes cluster. 

=== Installing the Open Liberty Operator 

To do so, first, install the Open Liberty Opertor 
deploy the microservice to Kubernetes from https://operatorhub.io/operator/open-liberty[OperatorHub^].

Run the following command to make sure that the operator is installed correctly:

[role='command']
```
kubectl get csv -n operators
```

You should see something similar to the following output:
[role="no_copy"]
----
NAME                           DISPLAY                 VERSION   REPLACES                       PHASE
open-liberty-operator.v0.7.0   Open Liberty Operator   0.7.0     open-liberty-operator.v0.6.0   Succeeded
----

=== Running the application

kubernetes.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-11/kubernetes.yaml[]
----

A Kubernetes resource definition is provided in the [hotspot file=0]`kubernetes.yaml` file at the `start/module-11` directory.

In the [hotspot file=0]`kubernetes.yaml` file, the custom resource (CR) is specified to be [hotspot=kind file=0]`OpenLibertyApplication`. The CR triggers the Open Liberty Operator to create, update or delete Kubernetes resources needed by the application to run on your cluster. Additionally, the [hotspot=applicationImage file=0]`applicationImage` field must be specified, and is set to the image created in the previous module. 

Run the following command to deploy the application into [hotspot=replicas file=0]`3` replicated pods as defined in the `kubernetes.yaml` file:
[role='command']
```
kubectl apply -f kubernetes.yaml
```

When the application is deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You see an output similar to the following if all the pods are working correctly:

[role="no_copy"]
----
NAME                                    READY   STATUS    RESTARTS   AGE
inventory-deployment-75f9dc56d9-g9lzl   1/1     Running   0          13s
inventory-deployment-75f9dc56d9-h8r75   1/1     Running   0          13s
inventory-deployment-75f9dc56d9-phdb6   1/1     Running   0          13s
----

You can check out the service at the http://localhost:31000/openapi/ui/[http://localhost:31000/openapi/ui/^] URL. Once you are done, you can delete all Kubernetes resources
by running the `kubectl delete` command:

[role='command']
```
kubectl delete -f kubernetes.yaml
```

[role='command']
include::{common-includes}/kube-minikube-teardown.adoc[]

=== Customizing deployments


== Support Licensing

use WebSphere Liberty


== Great work! You're done!

You just learnt to build a microservice in Open Liberty!

include::{common-includes}/attribution.adoc[]
