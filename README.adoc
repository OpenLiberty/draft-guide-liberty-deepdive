// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: liberty-deepdive
:page-layout: guide-multipane
:page-duration: 120 minutes
:page-releasedate: 2022-03-31
:page-essential: false
:page-description: Learn how to use Liberty to develop microservice.
:page-tags: ['Jakarta EE', 'MicroProfile']
:page-related-guides: []
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Implementing a microservice using Jakarta EE and MicroProfile API
:page-seo-description: A tutorial with examples on how to implement a microservice using Jakarta EE and Eclipse MicroProfile API.
:guide-author: Open Liberty
= Liberty deepdive class

[.hidden]
NOTE: This repository contains the documentation source. To view this exercise in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Liberty is a cloud-optimized Java runtime that is fast to start up with a low memory footprint and a development mode, known as dev mode, for quick iteration. Adding and removing features to adopt the latest open cloud-native Java API like MicroProfile and Jakarta EE are easy with Liberty. Liberty's zero migration lets you focus on what's important and not the APIs changing under you.

== What you'll learn

You will learn how to build a REST microservice with Jakarta EE and MicroProfile on Liberty. You will use Maven throughout this exercise to build the microservice as well as to interact with the running Liberty instance. Then, you’ll build a container image for the microservice and deploy it in Liberty Docker container to Kubernetes.

The microservice that you’ll be working with is called `inventory`. The `inventory` microservice persists data into a PostgreSQL database. You will also learn how to secure the REST endpoints and use JSON web token to communicate the provided `system` secured  microservice.

image::inventory.png[Inventory microservice,align="center"]

== Additional prerequisites

Before you begin, Docker needs to be installed before starting the module of Presisting Data. For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^]. You'll build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

Also, Kubernetes needs to be installed before starting the module of Deploying the microservice to Kubernetes.

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
Use Docker Desktop, where a local Kubernetes environment is pre-installed and enabled. If you do not see the _Kubernetes_ tab, then upgrade to the latest version of Docker Desktop.

Complete the setup for your operating system:

 - Set up  https://docs.docker.com/docker-for-windows/#kubernetes[Docker for Windows^]. 

After you complete the Docker setup instructions for your operating system, ensure that Kubernetes (not Swarm) is selected as the orchestrator in Docker Preferences.
--

[.tab_content.mac_section]
--
Use Docker Desktop, where a local Kubernetes environment is pre-installed and enabled. If you do not see the _Kubernetes_ tab, then upgrade to the latest version of Docker Desktop.

Complete the setup for your operating system:

 - Set up https://docs.docker.com/docker-for-mac/#kubernetes[Docker for Mac^].

After you complete the Docker setup instructions for your operating system, ensure that Kubernetes (not Swarm) is selected as the orchestrator in Docker Preferences.
--

[.tab_content.linux_section]
--
You will use `Minikube` as a single-node Kubernetes cluster that runs locally in a virtual machine.
Make sure you have `kubectl` installed. If you need to install `kubectl`, see the https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux[kubectl installation instructions^].
For Minikube installation instructions, see the https://github.com/kubernetes/minikube#installation[Minikube documentation^].
--


///////////////////////////
// Getting started
///////////////////////////

== Getting started

Clone the https://github.com/openliberty/guide-{projectid}.git[Git repository^]:

[source#git_clone, role="command", subs="attributes"]
----
git clone https://github.com/openliberty/guide-{projectid}.git
cd guide-{projectid}
----

The `start` directory is an empty directory that you will build the `inventory` service.

The `finish` directory contains the finished projects of different modules that you will build.

Before you begin, make sure you have all the necessary [.prerequisites]#prerequisites#.

== Getting started with Liberty and REST

To start developing your application, Liberty now has an easier way to get started by using the Open Liberty Starter. This tool provides a simple and quick way to get the necessary files to start building an application on Liberty. Through this tool, you can specify your application and project name. You can also choose a build tool from either Maven or Gradle, and pick the version of Java SE, Jakarta EE, and MicroProfile for your application.

In this workshop, the Open Liberty Starter is used to create the starting point of the application. Maven is used as the selected build tool and the application uses of Jakarta EE 9.1 and MicroProfile 5.

To get started with this tool, see the Getting Started page: https://openliberty.io/start/[https://openliberty.io/start/^]

When there, enter the properties that are needed for the application.

* Under Group specify: `io.openliberty.deepdive`
* Under Artifact specify: `inventory`
* Under Build Tool select: `Maven`
* Under Java SE Version select: `your version`
* Under Java EE/Jakarta EE Version select: `9.1`
* Under MicroProfile Version select: `5`

Then, click `Generate Project`. This downloads the starter project as `inventory.zip` file. 

Next, unpackage the `inventory.zip` file on your system. Move the contents of this extracted `inventory` directory to the start directory of this project as following path: `guide-liberty-deepdive/start/inventory`


=== Building the application

This application is configured to be built with Maven. Every Maven-configured project contains a `pom.xml` file, which defines the project configuration, dependencies, and plug-ins.

pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/pom.xml[]
----

Your [hotspot]`pom.xml` file is located in the `start/inventory` directory and is configured to include the [hotspot=libertyMavenPlugin]`liberty-maven-plugin`. Using the plug-in, you can install applications into Liberty and manage the server instances.

To begin, open a command-line session and navigate to your application directory. 

[role='command']
```
cd start/inventory
```

Build the system microservice that is provided and deploy it to Liberty by running the Maven `liberty:run` goal:

[role='command']
```
mvn liberty:run
```

The `mvn` command initiates a Maven build, during which the target directory is created to store all build-related files.

The `liberty:run` argument specifies the Liberty `run` goal, which starts a Liberty server instance in the foreground. As part of this phase, a Liberty server runtime is downloaded and installed into the `target/liberty/wlp` directory. Additionally, a server instance is created and configured in the `target/liberty/wlp/usr/servers/defaultServer` directory, and the application is installed into that server by using https://www.ibm.com/support/knowledgecenter/en/SSEQTP_liberty/com.ibm.websphere.wlp.doc/ae/rwlp_loose_applications.html[loose config^].

For more information about the Liberty Maven plug-in, see its https://github.com/WASdev/ci.maven[GitHub repository^].

When the server begins starting up, various messages display in your command-line session. Wait for the following message, which indicates that the server startup is complete:

[source, role="no_copy"]
----
[INFO] [AUDIT] CWWKF0011I: The server defaultServer is ready to run a smarter planet.
----

When you need to stop the server, press `CTRL+C` in the command-line session where you ran the server, or run the `liberty:stop` goal from the `start/inventory` directory in another command-line session:

[role='command']
```
mvn liberty:stop
```


=== Starting and stopping the Liberty server in the background

Although you can start and stop the server in the foreground by using the Maven `liberty:run` goal, you can also start and stop the server in the background with the Maven `liberty:start` and `liberty:stop` goals:

[role='command']
----
mvn liberty:start
mvn liberty:stop
----


=== Updating the server configuration without restarting the server

The Liberty Maven plug-in includes a `dev` goal that listens for any changes in the project, including application source code or configuration. The Liberty server automatically reloads the configuration without restarting. This goal allows for quicker turnarounds and an improved developer experience.

Stop the Liberty server if it is running, and start it in dev mode by running the `liberty:dev` goal in the `start/inventory` directory:

[role='command']
```
mvn liberty:dev
```

Dev mode automatically picks up changes that you make to your application and allows you to run tests by pressing the `enter/return` key in the active command-line session. When you’re working on your application, rather than rerunning Maven commands, press the `enter/return` key to verify your change.



=== Developing a RESTful microservice

Now that a basic Liberty application is running, the next step is to create the additional application and resource classes that are needed for this application. Within these classes, you use Jakarta REST, and other MicroProfile and Jakarta APIs.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `Inventory` class.#
`src/main/java/io/openliberty/deepdive/rest/Inventory.java`
----

Inventory.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/Inventory.java[]
----

This Inventory class stores a record of all systems and their system properties. The [hotspot=getSystem file=0]`getSystem()` method within this class retrieves and returns the system data from the system. The [hotspot=add file=0]`add()` method enables the addition of a system and its data to the inventory. The [hotspot=update file=0]`update()` method enables a system and its data on the inventory to be updated. The [hotspot=removeSystem file=0]`removeSystem()` method enables the deletion of a system from the inventory.


Create the `model` subdirectory, then create the `SystemData` class. The `SystemData` class is a Plain Old Java Object (POJO) that represents a single inventory entry. 

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\model
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/model
```
--


[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----

SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

The `SystemData` class contains the hostname, operating system name, Java version, and heap size properties. The various methods within this class allow the viewing or editing the properties of each system in the inventory.


[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

In Jakarta RESTful Web Service (restfulWS), a single class (like the `SystemResource.java` class) must represent a single resource, or a group of resources of the same type. In this application, a resource might be a system property, or a set of system properties. It is efficient to have a single class handle multiple different resources, but keeping a clean separation between types of resources helps with maintainability.

The [hotspot=path file=2]`@Path` annotation on this class indicates that this resource responds to the `/systems` path in the restfulWS application. The [hotspot=applicationPath file=2]`@ApplicationPath` annotation in the `RestApplication` class together with the [hotspot=path file=2]`@Path` annotation in the `SystemResource` class indicates that this resource is available at the `/api/systems` path.

The restfulWS maps the HTTP methods on the URL to the methods of the class by using annotations. This application uses the `GET` annotation to map an HTTP `GET` request to the `/api/systems` path.

The [hotspot=getListContents file=2]`@GET` annotation on the `listContents` method indicates that the method is to be called for the HTTP `GET` method. The [hotspot=producesListContents file=2]`@Produces` annotation indicates the format of the content that is returned. The value of the [hotspot=producesListContents file=2]`@Produces` annotation is specified in the HTTP `Content-Type` response header. For this application, a JSON structure is returned for these `Get` methods. The wanted `Content-Type` for a JSON response is `application/json` with `MediaType.APPLICATION_JSON` instead of the `String` content type. Using a constant such as `MediaType.APPLICATION_JSON` is better as in case of a spelling error, a compile failure occurs.

The restfulWS supports a number of ways to marshal JSON. The restfulWS specification mandates JSON-Binding (JSON-B). The method body returns the result of [hotspot=getSystems file=2]`inventory.getSystems()`. Because the method is annotated with [hotspot=producesListContents file=2]`@Produces(MediaType.APPLICATION_JSON)`, the restfulWS uses JSON-B to automatically convert the returned object to JSON data in the HTTP response.


=== Running the application

Because you started the Liberty server in dev mode at the beginning of this exercise, all the changes were automatically picked up.

Check out the service that you created at the http://localhost:9080/inventory/api/systems URL. If successful, it returns `[]` to you.


== Documenting APIs

Next, you will investigate how to document and filter RESTful APIs from annotations, POJOs (Plain old Java objects), and static OpenAPI files by using MicroProfile OpenAPI.

The OpenAPI specification, previously known as the Swagger specification, defines a standard interface for documenting and exposing RESTful APIs. This specification allows both humans and computers to understand or process the functionalities of services without requiring direct access to underlying source code or documentation. The MicroProfile OpenAPI specification provides a set of Java interfaces and programming models that allow Java developers to natively produce OpenAPI v3 documents from their restfulWS applications.

pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/pom.xml[]
----

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/liberty/config/server.xml[]
----

The MicroProfile OpenAPI API is included in the [hotspot=mp5 file=0]`microProfile` dependency that is specified in your `pom.xml` file. The [hotspot=mp5 file=1]`microProfile` feature that includes the `mpOpenAPI` feature is also enabled in the `server.xml` file.

=== Generating the OpenAPI document

Because the restfulWS framework handles basic API generation for restfulWS annotations, a skeleton OpenAPI tree can be generated from the existing inventory service. You can use this tree as a starting point and augment it with annotations and code to produce a complete OpenAPI document.

To see the generated OpenAPI tree, you can either visit the http://localhost:9080/openapi URL or visit the http://localhost:9080/openapi/ui URL for a more interactive view of the APIs. Click the `interactive UI` link on the welcome page. Within this UI, you can view each of the endpoints available in your application and any schemas. Each endpoint is colour coordinated to easily identify the type of request each is (for example GET, POST, PUT, DELETE, etc.). Clicking each endpoint within this UI enables you to view further details of each endpoint's parameters and responses. This UI is used for the remainder of this workshop to view and test the application endpoints.


=== Augmenting the existing restfulWS annotations with OpenAPI annotations

Because all restfulWS annotations are processed by default, you can augment the existing code with OpenAPI annotations without needing to rewrite portions of the OpenAPI document that are already covered by the restfulWS framework.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResources` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----


Add OpenAPI [hotspot=listContentsAPIResponseSchema hotspot=getSystemAPIResponseSchema file=0]`@APIResponseSchema`, [hotspot=addSystemAPIResponses file=0]`@APIResponses`, [hotspot=addSystemAPIResponse file=0]`@APIResponse`, [hotspot=addSystemParameters file=0]`@Parameters`, [hotspot=addSystemParameter file=0]`@Parameter`, and [hotspot=addSystemOperation file=0]`@Operation` annotations to the restfulWS methods, [hotspot=listContents file=0]`listContents()`, [hotspot=getSystem file=0]`getSystem()`, [hotspot=addSystem file=0]`addSystem()`, [hotspot=updateSystem file=0]`updateSystem()`, [hotspot=removeSystem file=0]`removeSystem()`, and [hotspot=addSystemClient file=0]`addSystemClient()`.

Note, the `@Parameter` annotation can be placed either [hotspot=getSystemParameter file=0]`inline` or [hotspot=removeSystemParameter file=0]`outline`. Examples of both have been provided within this class.

There are many OpenAPI annotations that can be used depending on what's best for your application and its classes. You can found all the annotations from the https://download.eclipse.org/microprofile/microprofile-open-api-3.0/microprofile-openapi-spec-3.0.html#_annotations[MicroProfile OpenAPI specification^].

Because the Liberty server was started in dev mode at the beginning of this exercise, your changes were automatically picked up. Go to the http://localhost:9080/openapi/ URL to see the updated endpoint descriptions. The endpoints at which your restfulWS methods are served now more meaningful:

[source, YAML, role="no_copy"]
----
---
openapi: 3.0.3
info:
  title: Generated API
  version: "1.0"
servers:
- url: http://localhost:9080/inventory
- url: https://localhost:9443/inventory
paths:
  /api/systems:
    get:
      summary: List contents.
      description: Returns the currently stored host:properties pairs in the inventory.
      operationId: listContents
      responses:
        "200":
          description: Returns the currently stored host:properties pairs in the inventory.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemData'
...
----

You can also visit the http://localhost:9080/openapi/ui to see each endpoint's updated description - click each of the icons within the UI to see the updated descriptions for each of the endpoints.

=== Augmenting POJOs with OpenAPI annotations

OpenAPI annotations can also be added to POJOs to describe what they represent. Currently, the OpenAPI document doesn't have a meaningful description of the `SystemData` POJO and hence it's difficult to tell exactly what this POJO is used for. To describe the `SystemData` POJO in more detail, augment the `SystemData.java` file with some OpenAPI annotations.

[role='code_command hotspot', subs="quotes"]
----
#Replace the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----

SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

Add OpenAPI `@Schema` annotations to the [hotspot=SystemDataSchema]`SystemData` class and the [hotspot=hostnameSchema]`hostname` variable.


Refresh the http://localhost:9080/openapi/ URL to see the updated OpenAPI tree. You should see much more meaningful data for the Schema:

[source, YAML, role="no_copy"]
----
components:
  schemas:
    SystemData:
      description: POJO that represents a single inventory entry.
      required:
      - hostname
      - properties
      type: object
      properties:
        hostname:
          type: string
        properties:
          type: object
----

Again, you can also view this in the http://localhost:9080/openapi/ui. Scroll down in the UI to the schemas section and open up the SystemData schema icon.

You can also use this UI to try out the various endpoints. In the UI, head to the POST request `/api/systems`. This endpoint enables you to create a system. Once you've opened this icon up, select the `Try it out` button on the right side. Now enter appropriate values for each of the required parameters and select the `Execute` button.

You can verify that this system has been created by testing the `/api/systems` GET request that returns the currently stored system data in the inventory. Execute this in the UI, then in the response body you should see your system and it's data listed.

You can follow these same steps for updating and deleting systems - visiting the corresponding endpoint in the UI, executing the endpoint and then verifying the result by using the `/api/systems` GET request endpoint.

You can learn more about MicroProfile OpenAPI from the https://openliberty.io/guides/microprofile-openapi.html[Documenting RESTful APIs guide^].


==  Configuring the microservice

Next, you can externalize Liberty server configuration and inject configuration for your microservice by using MicroProfile Config.


=== Enabling configurable ports and context root

So far you used hardcoded values to set the HTTP and HTTPS ports, and the context root for the Liberty server. These configurations can be externalized to change these values when you want to deploy your microservice by different ports and context root.

[role='code_command hotspot file=0', subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/liberty/config/server.xml[]
----

Add variables for the [hotspot=httpPortVariable file=0]`HTTP` port, [hotspot=httpsPortVariable file=0]`HTTPS` port and for the [hotspot=contextRootVariable file=0]`context root` to the `server.xml` file. Change the [hotspot=editedHttpEndpoint file=0]`httpEndpoint` element to reflect the new `default.http.port` and `default.http.port` variables and change the [hotspot=editedContextRoot file=0]`contextRoot` to use the new `default.context.root` variable too.

pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/pom.xml[]
----

[role='code_command hotspot file=1', subs="quotes"]
----
#Replace the `pom.xml` file.#
`pom.xml`
----

Add properties for the [hotspot=httpPort file=1]`HTTP` port, [hotspot=httpsPort file=1]`HTTPS` port and the [hotspot=contextRoot file=1]`context root` to the `pom.xml` file. 

You can try changing the value of these variables in the `pom.xml` file:

* update [hotspot=httpPort file=1]`liberty.var.default.http.port` to `9081`
* update [hotspot=httpsPort file=1]`liberty.var.default.https.port` to `9445`
* update [hotspot=contextRoot file=1]`liberty.var.default.context.root` to `/trial`.

Because you are using dev mode, these changes are automatically picked up by the server.

Now, you can access the application by the http://localhost:9081/trial/api/systems URL. Alternatively, for the updated OpenAPI UI, use the following URL http://localhost:9081/openapi/ui/.

When you are finished trying out changing this configuration, change the variables back to their original values.

* update [hotspot=httpPort file=1]`liberty.var.default.http.port` to `9080`
* update [hotspot=httpsPort file=1]`liberty.var.default.https.port` to `9443`
* update [hotspot=contextRoot file=1]`liberty.var.default.context.root` to `/inventory`.


=== Injecting static configuration

You can now explore how to use MicroProfile's Config API to inject static configuration into your microservice.

The MicroProfile Config API is included in the MicroProfile dependency that is specified in your `pom.xml` file. Look for the dependency with the `microprofile` artifact ID. This dependency provides a library that allows the use of the MicroProfile Config API. The `microProfile` feature is also enabled in the `server.xml` file.


First, you need to edit the `SystemResource` class to inject static configuration into the `CLIENT_PORT` variable.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

The [hotspot=inject file=0]`@Inject` annotation injects the value from other configuration sources to the `CLIENT_PORT` variable. The [hotspot=configProperty file=0]`@ConfigProperty` defines the external property name as `client.https.port`.

Update the [hotspot=printClientPort file=0]`POST` request so that the `/client/{hostname}` endpoint prints the `CLIENT_PORT` value.


=== Adding microprofile-config.properties file

Define the configurable variables in the `microprofile-config.properties` configuration file for the MicroProfile Config at the `src/main/resources/META-INF`

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\resources\META-INF
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir -p src/main/resources/META-INF
```
--

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `microprofile-config.properties` file.#
`src/main/resources/META-INF/microprofile-config.properties`
----

microprofile-config.properties
[source, text, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/resources/META-INF/microprofile-config.properties[]
----

Using the [hotspot=ordinal file=0]`config_ordinal` variable in this properties file, you can set the ordinal of this file and thus other configuration sources.

The [hotspot=configPort file=0]`client.https.port` variable enables the client port to be overwritten.

Revisit the OpenAPI UI `http://localhost:9080/openapi/ui/` to view these changes. Open the `/api/systems/client/{hostname}` endpoint and run it within the UI to view the `CLIENT_PORT` value.

You can learn more about MicroProfile Config from the https://openliberty.io/guides/microprofile-config.html[Configuring microservices guide^].

== Persisting data

Next, you’ll persist the system data into the PostgresSQL database by using https://jakarta.ee/specifications/persistence[Jakarta Persistence API^] (JPA).

Navigate to your application directory. 

[role='command']
```
cd start/inventory
```

=== Defining a JPA entity class

To store Java objects in a database, you must define a JPA entity class. A JPA entity is a Java object whose nontransient and nonstatic fields are persisted to the database. Any POJO class can be designated as a JPA entity. However, the class must be annotated with the `@Entity` annotation, must not be declared final and must have a public or protected nonargument constructor. JPA maps an entity type to a database table and persisted instances will be represented as rows in the table.

The [hotspot=SystemData]`SystemData` class is a data model that represents systems in the `inventory` microservice. Annotate it with JPA annotations.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----
SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-persisting-data/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

The following table breaks down the new annotations:

[cols="35, 200", options="header"]
|===
| *Annotation*    | *Description*
| [hotspot=Entity]`@Entity` | Declares the class as an entity
| [hotspot=Table]`@Table`  | Specifies details of the table such as name 
| [hotspot=NamedQuery]`@NamedQuery` | Specifies a predefined database query that is run by an `EntityManager` instance.
| [hotspot=Id]`@Id`       |  Declares the primary key of the entity
| [hotspot=GeneratedValue]`@GeneratedValue`    | Specifies the strategy that is used for generating the value of the primary key. The `strategy = GenerationType.IDENTITY` code indicates that the database will automatically increment the `inventoryid` automatically upon inserting into the database
| [hotspot=columnId hotspot=columnHostname hotspot=columnOsName hotspot=columnJavaVersion hotspot=columnHeapSize]`@Column`    | Specifies that the field is mapped to a column in the database table. The `name` attribute is optional and indicates the name of the column in the table
|===

=== Performing CRUD operations using JPA

The create, retrieve, update, and delete (CRUD) operations are defined in the Inventory. To perform these operations by using JPA, you need to update the `Inventory` class. 

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `Inventory` class.#
`src/main/java/io/openliberty/deepdive/rest/Inventory.java`
----

// File 0
Inventory.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-persisting-data/src/main/java/io/openliberty/deepdive/rest/Inventory.java[]
----

To use the entity manager at run time, inject it into your CDI bean through the
[hotspot=PersistenceContext file=0]`@PersistenceContext` annotation. The entity manager interacts with the persistence context. 
Every `EntityManager` instance is associated with a persistence context. The persistence context 
manages a set of entities and is aware of the different states that an entity can have.
The persistence context synchronizes with the database when a transaction commits.

// File 1
SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-persisting-data/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

The [hotspot=Inventory file=0]`Inventory` class has a method for each CRUD operation, so let's break them down:

* The [hotspot=add file=0]`add()` method persists an instance of the `SystemData` entity class to the data store by calling the [hotspot=Persist file=0]`persist()` method on an `EntityManager` instance. The entity instance becomes managed and changes to it will be tracked by the entity manager.

* The [hotspot=getSystems file=0]`getSystems()` method demonstrates a way to retrieve system objects from the database. This method returns a list of instances of the `SystemData` entity class by using the [hotspot=findAll file=1]`SystemData.findAll` query specified in the [hotspot=findAll hotspot=findSystem file=1]`@NamedQuery` annotation on the `SystemData` class. Similarly, the [hotspot=getSystem file=0]`getSystem()` method uses the [hotspot=findSystem file=1]`SystemData.findSystem` named query to find a system with the given hostname. 

* The [hotspot=update file=0]`update()` method creates a managed instance of a detached entity instance. The entity manager automatically tracks all managed entity objects in its persistence context for changes and synchronizes them with the database. However, if an entity becomes detached, you must merge that entity into the persistence context by calling the [hotspot=Merge file=0]`merge()` method so that changes to loaded fields of the detached entity are tracked.

* The [hotspot=removeSystem file=0]`removeSystem()` method removes an instance of the `SystemData` entity class from the database by calling the [hotspot=Remove file=0]`remove()` method on an `EntityManager` instance. The state of the entity is changed to removed and is removed from the database upon transaction commit. 

Declare the endpoints with transaction management. 

[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 2
SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-persisting-data/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

The `@Transactional` annotation is used in the [hotspot=postTransactional file=2]`POST`, [hotspot=putTransactional file=2]`PUT`, and [hotspot=deleteTransactional file=2]`DELETE` endpoints of the `SystemResource` class to declaratively control the transaction boundaries on the [hotspot=inventory file=2]`inventory` CDI bean. This ensures that the methods run within the boundaries of an active global transaction, which is why it is not necessary to explicitly begin, commit or rollback transactions. At the end of the transactional method invocation, the transaction commits and the persistence context flushes any changes to Event entity instances it is managing to the database.

=== Configuring JPA

The [hotspot file=0]`persistence.xml` file is a configuration file that defines a persistence unit. The
persistence unit specifies configuration information for the entity manager.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the configuration file.#
`src/main/resources/META-INF/persistence.xml`
----

// File 0
persistence.xml
[source, Xml, linenums, role='code_column']
----
include::finish/module-persisting-data/src/main/resources/META-INF/persistence.xml[]
----

The persistence unit is defined by the [hotspot=persistence-unit file=0]`persistence-unit` XML element. The [hotspot=transaction-type file=0]`name` attribute is required and is used to identify the persistent unit when using the `@PersistenceContext` annotation to inject the entity manager later in this exercise. The [hotspot=transaction-type file=0]`transaction-type="JTA"` attribute specifies to use Java Transaction API (JTA) transaction management. Because of using a container-managed entity manager, JTA transactions must be used. 

A JTA transaction type requires a JTA data source to be provided. The [hotspot=jta-data file=0]`jta-data-source` element specifies the Java Naming and Directory Interface (JNDI) name of the data source that is used. 


Configure the `jdbc/postgresql` data source in the Liberty server configuration file.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `server.xml` configuration file.#
`src/main/liberty/config/server.xml`
----

// File 1
server.xml
[source, Xml, linenums, role='code_column']
----
include::finish/module-persisting-data/src/main/liberty/config/server.xml[]
----

The [hotspot=postgresqlLibrary file=1]`library` element points the Liberty server where to find the postgresql library. The [hotspot=dataSource file=1]`dataSource` element points where the Java Database Connectivity (JDBC) should connect along with some database vendor-specific properties.

To use PostgreSQL database, you need to download its library and store to the Liberty shared resources directory. Configure the Liberty Maven plug-in in the `pom.xml` file.

[role='code_command hotspot file=2', subs="quotes"]
----
#Replace the `pom.xml` configuration file.#
`pom.xml`
----

// File 2
pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-persisting-data/pom.xml[]
----

The [hotspot=postgresql file=2]`postgresql` dependency ensures that Maven downloads the PostgreSQL library to local project. The [hotspot=copyDependencies file=2]`copyDependencies` configuration tells the Liberty Maven plug-in to copy the library to the Liberty shared resources directory.


=== Starting PostgreSQL database ===

Use Docker to run an instance of PostgreSQL database for a fast installation and setup.

A container file is provided for you. Navigate to the `finish/postgres` directory, run the following commands to use the `Dockerfile` to build the image, run the image in a Docker container, and map `5432` port from the container to your machine:

[role='command']
```
cd ../../finish/postgres
docker build -t postgres-sample .
docker run --name postgres-container -p 5432:5432 -d postgres-sample
```

=== Running the application ===

In your dev mode console for the `inventory` microservice, type `r` and press `enter/return` key to restart the server.

Point your browser to the link:http://localhost:9080/openapi/ui/[^] URL.
This URL displays the available REST endpoints.

First, make a POST request to the `/api/systems/` endpoint. To make this request, expand the first POST endpoint on the UI, click the `Try it out` button, provide values to the `heapSize`, `hostname`, `javaVersion`, and `osName` parameters, and then click the `Execute` button. The POST request adds a system with the specified values to the database.

Next, make a GET request to the `/api/systems` endpoint. To make this request, expand the GET endpoint on the UI, click the `Try it out` button, and then click the `Execute` button. The GET request returns all systems from the database.

Next, make a PUT request to the `/api/systems/{hostname}`. To make this request, expand the PUT endpoint on the IO, click the `Try it out` button, provide the same value to the `hostname` parameter as the previous step, provide different values to the `heapSize`, `javaVersion`, and `osName` parameters, and then click the `Execute` button. The PUT request updates the system with the specified values. 

To see the updated system, make a GET request to the `/api/systems/{hostname}` endpoint. To make this request, expand the GET endpoint on the UI, click the `Try it out` button, provide the same value to the `hostname` parameter as the previous step, and then click the `Execute` button. The GET request returns the system from the database.

Next, make a DELETE request to the `/api/systems/{hostname}`. To make this request, expand the DELETE endpoint on the IO, click the `Try it out` button, and then click `Execute`. The DELETE request removes the system from the database. Run the GET request again to see that the system does not exist from the database. 

== Securing RESTful APIs

Now you can secure your RESTful APIs. Navigate to your application directory. 

[role='command']
```
cd start/inventory
```

Begin by adding some users and user groups to your `server.xml` Liberty configuration file.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

// File 0
server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-securing/src/main/liberty/config/server.xml[]
----

The [hotspot=basicregistry file=0]`basicRegistry` contains a list of all users for the application and their passwords, as well as all of the user groups. The [hotspot=myadmins file=0]`admin` group tells the application which of the users are in the administrator group. The [hotspot=myusers file=0]`user` group tells the application which users are in the user group.

The `security-role` maps the [hotspot=adminrole file=0]`admin` role to the [hotspot=myadmins file=0]`admin` group, meaning that all users in the `admin` group have the administrator role. Similarly, the [hotspot=userrole file=0]`user` role is mapped to the [hotspot=myusers file=0]`user` group, meaning all users in the `user` group have the user role.

Your application has the following users and passwords:

[cols="<35, ^200, ^200"]
|===
| *Username* | *Password* | *Role*
| bob | bobpwd | admin, user
| alice | alicepwd | user
|===

Now you will secure the `inventory` service.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 1
SystemResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-securing/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

This class now has role-based access control. The role names that are used in the [hotspot=putRolesAllowed hotspot=deleteRolesAllowed file=1]`@RolesAllowed` annotations are mapped to group names in the groups claim of the JSON Web Token (JWT). This mapping results in an authorization decision wherever the security constraint is applied.

The [hotspot=putEndpoint file=1]`/{hostname}` endpoint that is annotated with the [hotspot=put file=1]`@PUT` annotation updates a system in the inventory. This `PUT` endpoint is annotated with the [hotspot=putRolesAllowed file=1]`@RolesAllowed({ "admin", "user" })` annotation. Only authenticated users with the role of `admin` or `user` can access this endpoint.

The [hotspot=deleteEndpoint file=1]`/{hostname}` endpoint that is annotated with the [hotspot=delete file=1]`@DELETE` annotation removes a system from the inventory. This `DELETE` endpoint is annotated with the [hotspot=deleteRolesAllowed file=1]`@RolesAllowed({ "admin" })` annotation. Here, only authenticated users with the role of `admin` can access this endpoint.

You can manually check that the `inventory` microservice is secured by making requests to the `PUT` and `DELETE` endpoints.

Before making requests, you must add a system to the inventory. Try adding a system by using the `POST` endpoint `/systems` by running the following command:

[role='command']
----
curl -X POST 'http://localhost:9080/inventory/api/systems?hostname=localhost&osName=mac&javaVersion=11&heapSize=1'
----

You can expect the following response:

[source, role="no_copy"]
----
{ "ok" : "localhost was added." }
----

This command calls the `/systems` endpoint and adds a system `localhost` to the inventory. You can validate that the command worked by calling the `/systems` endpoint with a `GET` request to retrieve all the systems in the inventory, with the following curl command:

[role='command']
----
curl 'http://localhost:9080/inventory/api/systems'
----

You can now expect the following response:

[source, role=no_copy]
----
[{"heapSize":1,"hostname":"localhost","javaVersion":"11","osName":"mac","id":23}]
----

Now try calling your secure `PUT` endpoint to update the system that you just added by the following curl command:

[role='command']
----
curl -k --user alice:alicepwd -X PUT 'https://localhost:9443/inventory/api/systems/localhost?osName=mac&javaVersion=17&heapSize=2'
----

As this endpoint is accessible to the groups `user` and `admin`, you log in with `user` credentials and updated the system.

You should see the following response:

[source, role=no_copy]
----
{ "ok" : "localhost was updated." }
----

This response means that you logged in successfully as an authenticated `user`, and that the endpoint works as expected.

Now try calling the `DELETE` endpoint. As this endpoint is only accessible to `admin` users, you can expect this command to fail if you attempt to access it with a user in the `user` group.

You can check that your application is secured against these requests with the following command:

[role='command']
----
curl -k --user alice:alicepwd -X DELETE 'https://localhost:9443/inventory/api/systems/localhost'
----

As `alice` is part of the `user` group, this request cannot work. In your dev mode console, you can expect the following output:

[source, role=no_copy]
----
jakarta.ws.rs.ForbiddenException: Unauthorized
----

Now attempt to call this endpoint with an authenticated `admin` user that can work correctly. Run the following curl command:

[role='command']
----
curl -k --user bob:bobpwd -X DELETE  'https://localhost:9443/inventory/api/systems/localhost'
----

You can expect to see the following response:

[source, role=no_copy]
----
{ "ok" : "localhost was removed." }
----

This response means that your endpoint is secure. Validate that it works correctly by calling the `/systems` endpoint with the following curl command:

[role='command']
----
curl 'http://localhost:9080/inventory/api/systems'
----

You can expect to see the following output:

[source, role=no_copy]
----
[]
----

This response shows that the endpoints work as expected and that the system you added was successfully deleted.

== Consuming the secured RESTful APIs by JWT

You can now implement JSON Web Tokens (JWT) and configure them as Single Sign On (SSO) cookies to use the RESTful APIs. The JWT generated by Liberty is used to communicate securely between the `inventory` and `system` microservices. You can implement the `/client/{hostname}` POST endpoint to collect the properties from the `system` microservices and create a system in the inventory. 

The `system` microservice is provided for you.

=== Writing the RESTful client interface
Create the `client` subdirectory. Then, create a RESTful client interface for the `system` microservice in the `inventory` microservice.

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\client
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/client
```
--


[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemClient` interface.#
`src/main/java/io/openliberty/deepdive/rest/client/SystemClient.java`
----

// File 0
SystemClient.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/SystemClient.java[]
----


This interface declares methods for accessing each of the endpoints that are set up for you in the `system` service. The MicroProfile Rest Client feature automatically builds and generates a client implementation based on what is defined in the [hotspot file=0]`SystemClient` interface. You don’t need to set up the client and connect with the remote service.

Now create the required exception classes that are used by the `SystemClient` instance.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `UnknownUriException` class.#
`src/main/java/io/openliberty/deepdive/rest/client/UnknownUriException.java`
----

// File 1
UnknownUriException.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/UnknownUriException.java[]
----

This class is an exception that is thrown when an unknown URI is passed to the `SystemClient`.

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `UnknownUriExceptionMapper` class.#
`src/main/java/io/openliberty/deepdive/rest/client/UnknownUriExceptionMapper.java`
----

// File 2
UnknownUriExceptionMapper.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/UnknownUriExceptionMapper.java[]
----

This class links the `UnknownUriException` class with the corresponding response code through a `ResponseExceptionMapper` mapper class.

=== Implementing the `/client/{hostname}` endpoint

Now implement the `/client/{hostname}` `POST` endpoint of the `SystemResource` class to consume the secured `system` microservice.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 0
SystemResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

The [hotspot=getSystemClient file=0]`getSystemClient()` method builds and returns a new instance of the `SystemClient` class for the hostname provided. The [hotspot=addSystemClient file=0]`/client/{hostname}` `POST` endpoint uses this method to create a rest client that is called [hotspot=getCustomRestClient file=0]`customRestClient` to consume the `system` microservice.  

A JWT instance is injected to the [hotspot=jwt file=0]`jwt` field variable by the `jwtSso` feature. It is used to create the [hotspot=authHeader file=0]`authHeader` authentication header. It is then passed as a parameter to the endpoints of the [hotspot=customRestClient file=0]`customRestClient` to get the properties from the `system` microservice. A [hotspot=addSystem file=0]`system` is then added to the inventory.

=== Configuring the JSON Web Token

Next, add the JSON Web Token (Single Sign On) feature to the server configuration file for the `inventory` service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

// File 0
server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/liberty/config/server.xml[]
----

// File 1
microprofile-config.properties
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/webapp/META-INF/microprofile-config.properties[]
----

The [hotspot=jwtSsoFeature file=0]`jwtSso` feature adds the libraries that are required for JWT SSO implementation. Configure the [hotspot=jwtSsoConfig file=0]`jwtSso` feature by adding the [hotspot=jwtBuilder file=0]`jwtBuilder` configuration to your `server.xml`. Also, configure the MicroProfile [hotspot=mpJwt file=0]`JWT` with the `audiences` and `issuer` properties that match the [hotspot file=1]`microprofile-config.properties`  defined at the `system/src/main/webapp/META-INF` directory under the `system` project.

The [hotspot=keyStore file=0]`keyStore` element is used to define the repository of security certificates used for SSL encryption. The `id` attribute is an unique configuration id, which is set to `defaultKeyStore`. The `password` attribute is used to load the keystore file, and its value can be stored in clear text or encoded form. To learn more about other attributes, visit the https://openliberty.io/docs/latest/reference/config/keyStore.html#keyStore.html[keyStore reference^]. Because the keyStore file is not provided at the `src` directory, Liberty create a Public Key Cryptography Standards #12 (PKCS12) keystore file for you by default.

The [hotspot=keyStore file=0]`keyStore` must be the same in both `system` and `inventory` microservices. As the configured `system` microservice is already provided for you, copy the `key.p12` key store file from the `system` microservice to your `inventory` service.

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\liberty\config\resources\security
copy ..\finish\system\src\main\liberty\config\resources\security\key.p12 src\main\liberty\config\resources\security\key.p12
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir -p src/main/liberty/config/resources/security
cp ../finish/system/src/main/liberty/config/resources/security/key.p12 src/main/liberty/config/resources/security/key.p12
```
--

Now configure the client https port in the `pom.xml` configuration file.

[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the `pom.xml` file.#
`pom.xml`
----

// File 2
pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/pom.xml[]
----

Configure the client https port by setting the [hotspot=https file=2]`<liberty.var.client.https.port>` to `9444`.

In your dev mode console for the `inventory` microservice, type `r` and press `enter/return` key to restart the server.

=== Running the `/client/{hostname}` endpoint

Open another command-line session and run the `system` microservice from the `finish` directory.

[role='command']
----
cd finish/system
mvn liberty:run
----

You can check that the system service is secured against unauthenticated requests at https://localhost:9444/system/api/heapsize. You can expect to see the following error at the console of running the `system` microservice:

[source]
----
CWWKS5522E: The MicroProfile JWT feature cannot perform authentication because a MicroProfile JWT cannot be found in the request.
----

You can check that the `/client/{hostname}` endpoint you updated can access the `system` microservice. 

Make an authorized request to the new `/client/{hostname}` endpoint.
As this endpoint is restricted to `admin`, you can use the login credentials for `bob` as it is in the `admin` group.

[role='command']
----
curl -k --user bob:bobpwd -X POST 'https://localhost:9443/inventory/api/systems/client/localhost'
----

You can expect the following output:

[source, role='no_copy']
----
{ "ok" : "localhost was added." }
----

You can verify that this endpoint works as expected by running the following command:

[role='command']
----
curl 'http://localhost:9080/inventory/api/systems'
----

You can expect to see your system listed in the output.

[source]
----
[
  {
    "heapSize": 8589934592,
    "hostname": "localhost",
    "javaVersion": "16.0.1",
    "osName": "Mac OS X"
  }
]
----

== Adding health checks
Next, you'll use MicroProfile Health to report the health status of the microservice and PostgreSQL database connection.

Navigate to your application directory

```
cd start/inventory
```

A health report will be generated automatically for all health services that enable MicroProfile Health.

All health services must provide an implementation of the `HealthCheck` interface, which is used to verify their health. MicroProfile Health offers health checks for startup, liveness, and readiness.

A startup check allows applications to define startup probes that are used for initial verification of the application before the liveness probe takes over. For example, a startup check might check which applications require additional startup time on their first initialization.

A liveness check allows third-party services to determine whether a microservice is running. If the liveness check fails, the application can be terminated. For example, a liveness check might fail if the application runs out of memory.

A readiness check allows third-party services, such as Kubernetes, to determine whether a microservice is ready to process requests.

Create the `health` subdirectory before creating the health check classes.

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\health
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/health
```
--

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `StartupCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/health/StartupCheck.java`
----

StartupCheck.java
[source, java, linenums, role='code_column tags=StartupCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/StartupCheck.java[]
----

The [hotspot=Startup file=0]`@Startup` annotation indicates that this class is a startup health check procedure. Navigate to http://localhost:9080/health/started to check the status of the startup health check.
In this case, you are checking the cpu usage. If more than 95% of the cpu
is being used, a status of `DOWN` is returned.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `LivenessCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/health/LivenessCheck.java`
----

LivenessCheck.java
[source, java, linenums, role='code_column tags=LivenessCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/LivenessCheck.java[]
----

The [hotspot=Liveness file=1]`@Liveness` annotation indicates that this class is a liveness health check procedure. Navigate to http://localhost:9080/health/live to check the status of the liveness health check.
In this case, you are checking the heap memory usage. If more than 90% of the maximum memory
is being used, a status of `DOWN` is returned.

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `ReadinessCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/ReadinessCheck.java`
----

ReadinessCheck.java
[source, java, linenums, role='code_column tags=ReadinessCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/ReadinessCheck.java[]
----
The [hotspot=Readiness file=2]`@Readiness` annotation indicates that this class is a readiness health check procedure. Navigate to http://localhost:9080/health/ready to check the status of the liveness health check. This tests the connection to the PostgreSQL container created earlier in the guide. If the connection is refused, a status of `DOWN` is returned.

Or, you can visit the http://localhost:9080/health URL to see the overall health status of the application.

== Providing metrics

use MicroProfile Metrics to provide metrics from the microservice

== Testing the microservice

use test containger to test the microservice

== Building the container 

Press `CTRL+C` in the command-line session to stop the dev mode `mvn liberty:dev` that was started in the previous section. Navigate to your application directory if you are not:

```
cd start/inventory
```

The first step to containerizing your application inside of a Docker container is creating a Dockerfile. A Dockerfile is a collection of instructions for building a Docker image that can then be run as a container. 

Make sure to start your Docker daemon before you proceed.

[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Dockerfile` in the `start/inventory` directory.#
`Dockerfile`
----

Dockerfile
[source, text, linenums, role="code_column"]
----
include::finish/module-kubernetes/Dockerfile[]
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your image is built. In this case, you’re using the `icr.io/appcafe/open-liberty:full-java11-openj9-ubi` image as your parent image, which comes with the latest Open Liberty runtime.

To help you manage your images, you can label your container images with the [hotspot=label file=0]`LABEL` command. 

The [hotspot=copy file=0]`COPY` instructions are structured as `COPY` `[--chown=<user>:<group>]` `<source>` `<destination>`. They copy local files into the specified destination within your Docker image. In this case, the first [hotspot=copy-config file=0]`COPY` instruction copies the server configuration file that is at `src/main/liberty/config/server.xml` to the `/config/` destination directory. Similarly, the second [hotspot=copy-war file=0]`COPY` instruction copies the `.war` file to the `/config/apps` destination directory. The third [hotspot=copy-postgres file=0]`COPY` instruction copies the PostgreSQL library file to the Liberty shared resources directory.


=== Developing the application in a container

Using the Dockerfile, you can try out your application with it by using the `devc` goal.

The Open Liberty Maven plug-in includes a `devc` goal that simplifies developing your application in a container by starting dev mode with container support. This goal builds a Docker image, mounts the required directories, binds the required ports, and then runs the application inside of a container. Dev mode also listens for any changes in the application source code or configuration and rebuilds the image and restarts the container as necessary.

Retrieve the PostgreSQL container IP address by running the following command:

[role='command']
```
docker inspect -f "{{.NetworkSettings.IPAddress }}"  postgres-container
```

The command returns the PostgreSQL container IP address:

[role="no_copy"]
----
172.17.0.2
----

Build and run the container by running the `devc` goal with the PostgreSQL container IP address from the `start/inventory` directory. If your PostgreSQL container IP address is not `172.17.0.2`, replace the command with the right IP address.

[role='command']
```
mvn liberty:devc -DdockerRunOpts="-e POSTGRES_HOSTNAME=172.17.0.2" -DserverStartTimeout=120
```

After you see the following message, your application server in dev mode is ready:
[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
*    ...
*    Docker network information:
*        Container name: [ liberty-dev ]
*        IP address [ 172.17.0.2 ] on Docker network [ bridge ]
*    ...
----

Open another command-line session and run the following command to make sure that your
container is running and didn’t crash:

[role='command']
```
docker ps 
```

You can see something similar to the following output:

[role="no_copy"]
----
CONTAINER ID  IMAGE               COMMAND                 CREATED        STATUS        PORTS                                                                   NAMES
ee2daf0b33e1  inventory-dev-mode  "/opt/ol/helpers/run…"  2 minutes ago  Up 2 minutes  0.0.0.0:7777->7777/tcp, 0.0.0.0:9080->9080/tcp, 0.0.0.0:9443->9443/tcp  liberty-dev
----

Point your browser to the http://localhost:9080/openapi/ui URL to try out your application. 

When you're finished trying out the microservice, press `CTRL+C` in the command-line session that the dev mode was started from to stop and remove the container.

Also, run the following commands to stop the PostgreSQL container that was started in the previous section.

[role='command']
```
docker stop postgres-container
docker rm postgres-container
```

=== Building the container image

Run the `mvn package` command from the `start/inventory` directory so that the `.war` file resides in the `target` directory.

[role='command']
```
mvn package
```

Build your Docker image with the following commands:

[role='command']
```
docker build -t liberty-deepdive-inventory:1.0-SNAPSHOT .
```

When the build finishes, run the following command to list all local Docker images:
[role='command']
```
docker images
```

Verify that the `liberty-deepdive-inventory:1.0-SNAPSHOT` image is listed among the Docker images, for example:
[source, role="no_copy"]
----
REPOSITORY                      TAG
liberty-deepdive-inventory      1.0-SNAPSHOT
openliberty/open-liberty        full-java11-openj9-ubi
----

== Deploying the microservice to Kubernetes

Now that the containerized application is built, deploy it to a local Kubernetes cluster. 

=== Installing the Open Liberty Operator 

To do so, first, install the Open Liberty Operator to deploy the microservice to Kubernetes.

First, install Custom Resource Definitions (CRDs) for the Open Liberty Operator by running the following command:
[role='command']
```
kubectl apply -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
Custom Resources extend the Kubernetes API and enhance its functionality.

Set environment variables for namespaces for the Operator by running the following commands:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
set OPERATOR_NAMESPACE=default
set WATCH_NAMESPACE=\"\"
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
OPERATOR_NAMESPACE=default
WATCH_NAMESPACE='""'
```
--

Next, run the following commands to install cluster-level role-based access:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
curl https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml -o openliberty-app-rbac-watch-all.yaml

powershell -Command "(gc .\openliberty-app-rbac-watch-all.yaml) -replace 'OPEN_LIBERTY_OPERATOR_NAMESPACE', '%OPERATOR_NAMESPACE%' | Out-File -encoding ASCII .\openliberty-app-rbac-watch-all.yaml"

kubectl apply -f .\openliberty-app-rbac-watch-all.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml \
  | sed -e "s/OPEN_LIBERTY_OPERATOR_NAMESPACE/${OPERATOR_NAMESPACE}/" \
  | kubectl apply -f -
```
--

Finally, run the following commands to install the Operator:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
curl https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml -o openliberty-app-operator.yaml

powershell -Command "(gc .\openliberty-app-operator.yaml) -replace 'OPEN_LIBERTY_WATCH_NAMESPACE', '%WATCH_NAMESPACE%' | Out-File -encoding ASCII .\openliberty-app-operator.yaml"

kubectl apply -n %OPERATOR_NAMESPACE% -f .\openliberty-app-operator.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml \
  | sed -e "s/OPEN_LIBERTY_WATCH_NAMESPACE/${WATCH_NAMESPACE}/" \
  | kubectl apply -n ${OPERATOR_NAMESPACE} -f -
```
--

To check that the Open Liberty Operator is installed successfully, run the following command to view all the supported API resources that are available through the Open Liberty Operator:
[role='command']
```
kubectl api-resources --api-group=apps.openliberty.io
```

Look for the following output, which shows the https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[custom resource definitions^] (CRDs) that can be used by the Open Liberty Operator:

[role='no_copy']
```
NAME                      SHORTNAMES         APIGROUP              NAMESPACED   KIND
openlibertyapplications   olapp,olapps       apps.openliberty.io   true         OpenLibertyApplication
openlibertydumps          oldump,oldumps     apps.openliberty.io   true         OpenLibertyDump
openlibertytraces         oltrace,oltraces   apps.openliberty.io   true         OpenLibertyTrace
```

Each CRD defines a kind of object that can be used, which is specified in the previous example by the `KIND` value. The `SHORTNAME` value specifies alternative names that you can substitute in the configuration to refer to an object kind. For example, you can refer to the `OpenLibertyApplication` object kind by one of its specified shortnames, such as `olapps`. 

The `openlibertyapplications` CRD defines a set of configurations for deploying an Open Liberty-based application, including the application image, number of instances, and storage settings. The Open Liberty Operator watches for changes to instances of the `OpenLibertyApplication` object kind and creates Kubernetes resources that are based on the configuration that is defined in the CRD.

=== Deploying the container image


[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `inventory.yaml` in the `start/inventory` directory.#
`inventory.yaml`
----

// File 0
inventory.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-kubernetes/inventory.init.yaml[]
----

In the [hotspot file=0]`inventory.yaml` file, the custom resource (CR) is specified to be [hotspot=kind file=0]`OpenLibertyApplication`. The CR triggers the Open Liberty Operator to create, update, or delete Kubernetes resources that are needed by the application to run on your cluster. Additionally, the [hotspot=applicationImage file=0]`applicationImage` field must be specified, and is set to the image created in the previous module. 

// File 1
postgres.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/postgres/postgres.yaml[]
----

Similarly, a Kubernetes resource definition is provided in the [hotspot file=1]`postgres.yaml` file at the `finish/postgres` directory. In the `postgres.yaml` file, the deployment for the PostgresSQL database is defined. 

// To ensure that data persists even when a container does not, a [hotspot=persistentVolume file=1]`PersistentVolume` resource is defined. It allows the data from the database to be stored in a permanent location. The [hotspot=persistentVolumeClaim file=1]`PersistentVolumeClaim` acts to request the `PersistentVolume` resource. Next, the [hotspot=deployment file=1]`Deployment` acts to deploy the necessary Kubernetes resources to serve the database. Finally, the [hotspot=service file=1]`Service` exposes the PostgreSQL service on a cluster-internal IP, so the inventory service can make requests to it.

Create a Kubernetes Secret to configure the credentials for accessing the database by the user `admin`.
[role='command']
```
kubectl create secret generic post-app-credentials --from-literal username=admin --from-literal password=adminpwd
```

The credentials are passed to the PostgreSQL database service as environment variables in the [hotspot=env file=1]`env` field.

Run the following command to deploy the application and database:
[role='command']
```
kubectl apply -f inventory.yaml
kubectl apply -f ../../finish/postgres/postgres.yaml
```

When deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You see an output similar to the following if all the pods are working correctly:

[role="no_copy"]
----
NAME                                    READY   STATUS    RESTARTS   AGE
inventory-deployment-75f9dc56d9-g9lzl   1/1     Running   0          35s
postgres-58bd9b55c7-6vzz8               1/1     Running   0          13s
olo-controller-manager-6fc6b456dc-s29wl 1/1     Running   0          10m
----

You can check out the service at the https://localhost:31000/openapi/ui/[https://localhost:31000/openapi/ui/^] URL.  The servers dropdown list shows the `\https://localhost:31000/inventory` URL. Or, you can run the following command to access the inventory microservice:
[role='command']
```
curl -k https://localhost:31000/inventory/api/systems
```

=== Customizing deployments


// File 0
server.xml
[source, xml, linenums, role='code_column']
----
include::finish/module-kubernetes/server.xml[]
----

You can modify the inventory deployment to customize the service. Customizations for a service include changing the port number, changing the context root, and passing confidential information by using Secrets. 

In the [hotspot file=0]`server.xml`, the [hotspot=contextRoot file=0]`default.context.root` variable is defined. The context root for the inventory service can be changed by using this variable. The value for the [hotspot=contextRoot file=0]`default.context.root` variable can be defined in a ConfigMap and accessed as an environment variable.

Create a ConfigMap to configure the app name with the following `kubectl` command.
[role='command']
```
kubectl create configmap inv-app-root --from-literal contextRoot=/dev
```
This command deploys a ConfigMap named `inv-app-root` to your cluster. It has a key called `contextRoot` with a value of `/dev`. The `--from-literal` flag specifies individual key-value pairs to store in this ConfigMap. 


[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `inventory.yaml` file.#
`inventory.yaml`
----

// File 1
inventory.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/module-kubernetes/inventory.yaml[]
----

During deployment, `post-app-credentials` secret can be mounted to the [hotspot=mountPath file=1]`/config/variables/postgres` in the pod to create Liberty config variables. Liberty creates variables from the files in the [hotspot=mountPath file=1]`/config/variables/postgres` directory. Instead of including confidential information in the `server.xml`, users can access it using normal Liberty variable syntax, [hotspot=postgresUser file=0]`${postgres/username}` and [hotspot=postgresUser file=0]`${postgres/password}`.

Finally, the [hotspot=port file=1]`port` number is updated to `30000`, so the service is now available at port `30000`.

Run the following command to deploy your changes.
[role='command']
```
kubectl apply -f inventory.yaml
```

You can now check out the service at the https://localhost:30000/openapi/ui/[https://localhost:30000/openapi/ui/^] URL. The servers dropdown list shows the `\https://localhost:30000/dev` URL. Or, you can run the following command to access the inventory microservice:
[role='command']
```
curl -k https://localhost:30000/dev/api/systems
```

=== Tearing down the environment 

When you're finished trying out the microservice, you can delete all Kubernetes resources by running the `kubectl delete` commands:

[role='command']
```
kubectl delete -f inventory.yaml
kubectl delete -f ../../finish/postgres/postgres.yaml
kubectl delete configmap inv-app-root
kubectl delete secret post-app-credentials
```

To uninstall the Open Liberty Operator, run the following commands:

[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
set OPERATOR_NAMESPACE=default
set WATCH_NAMESPACE=\"\"

kubectl delete -n %OPERATOR_NAMESPACE% -f .\openliberty-app-operator.yaml

kubectl delete -f .\openliberty-app-rbac-watch-all.yaml

kubectl delete -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
OPERATOR_NAMESPACE=default
WATCH_NAMESPACE='""'

curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-operator.yaml \
  | sed -e "s/OPEN_LIBERTY_WATCH_NAMESPACE/${WATCH_NAMESPACE}/" \
  | kubectl delete -n ${OPERATOR_NAMESPACE} -f -

curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-rbac-watch-all.yaml \
  | sed -e "s/OPEN_LIBERTY_OPERATOR_NAMESPACE/${OPERATOR_NAMESPACE}/" \
  | kubectl delete -f -

kubectl delete -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/0.8.0/kubectl/openliberty-app-crd.yaml
```
--

== Support Licensing

Open Liberty is Open Source under the Eclipse Public License v1, as a result there is no fee to use in production. Community support is available at StackOverflow, Gitter, or the mail list, and bugs can be raised in https://github.com/openliberty/open-liberty[GitHub^]. Commercial support from IBM is available for Open Liberty, you can find out more on the https://www.ibm.com/uk-en/marketplace/elite-support-for-open-liberty[IBM Marketplace^]. The WebSphere Liberty product is built on Open Liberty, there is no migration that is required to use WebSphere Liberty, you simply point to WebSphere Liberty in your build. Users of WebSphere Liberty get support for the packaged Open Liberty function.

WebSphere Liberty is also available in https://search.maven.org/search?q=g:com.ibm.websphere.appserver.runtime[Maven Central^].

You can use WebSphere Liberty for development even if you haven't purchased it, but if you have production entitlement you can easily change to use it, as follows:

In the `pom.xml`, add the `<configuration>` element as the following:

```XML
  <plugin>
      <groupId>io.openliberty.tools</groupId>
      <artifactId>liberty-maven-plugin</artifactId>
      <version>3.5.1</version>
      <configuration>
          <runtimeArtifact>
              <groupId>com.ibm.websphere.appserver.runtime</groupId>
              <artifactId>wlp-kernel</artifactId>
               <version>[22.0.0.4,)</version>
               <type>zip</type>
          </runtimeArtifact>
      </configuration>
  </plugin>
```

Rebuild and restart the `inventory` service by dev mode:

[role='command']
```
mvn clean
mvn liberty:dev
```


== Great work! You're done!

You just learnt to build a microservice in Liberty!

include::{common-includes}/attribution.adoc[]
